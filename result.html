<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>결과</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    input, button { padding: 10px 12px; border: 1px solid #ccc; border-radius: 10px; }
    button { cursor: pointer; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .card { border:1px solid #eee; border-radius:12px; padding:16px; margin:12px 0; }
    .small { color:#666; font-size:12px; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 10px; text-align:left; }
    th { background:#fafafa; }
    .badge { font-size:12px; padding:4px 8px; border-radius:999px; background:#f3f4f6; }
    a { word-break: break-all; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 960px) { .grid { grid-template-columns: 1fr 1fr; } }
    canvas { max-width: 100%; }
  </style>
</head>
<body>
  <h1>결과</h1>

  <!-- 세션 로드 -->
  <div class="card">
    <h2>1) 세션 불러오기</h2>
    <div class="row">
      <input id="sessionId" placeholder="session UUID" style="flex:1; min-width:260px;" />
      <button id="load">불러오기</button>
      <span id="msg" class="small"></span>
    </div>
    <p class="small">방장이 준 링크(result.html?session=...)로 들어오면 자동 입력됩니다.</p>
  </div>

  <!-- 요약 -->
  <div id="summary" class="card" style="display:none;">
    <h2 id="title"></h2>
    <div class="row">
      <span class="badge" id="meta"></span>
      <span class="badge" id="voteCount"></span>
    </div>
    <p class="small">
      익명 집계만 표시합니다. (개별 투표자가 누구인지, 누가 누구에게 투표했는지는 공개하지 않음)
    </p>
  </div>

  <!-- 차트 -->
  <div id="charts" class="card" style="display:none;">
    <h2>2) 시각화</h2>
    <div class="grid">
      <div class="card">
        <h3 style="margin-top:0;">점수 막대 그래프 (Borda)</h3>
        <canvas id="barScore"></canvas>
        <p class="small">점수는 Borda 합계입니다. (1등=M-1점, 2등=M-2점 …)</p>
      </div>
      <div class="card">
        <h3 style="margin-top:0;">1등 득표 비중 (파이)</h3>
        <canvas id="pieFirst"></canvas>
        <p class="small">각 후보가 “1등”으로 선택된 횟수 비율입니다.</p>
      </div>
    </div>
  </div>

  <!-- 결과 표 -->
  <div id="resultCard" class="card" style="display:none;">
    <h2>3) 집계 결과</h2>
    <table>
      <thead>
        <tr>
          <th style="width:80px;">순위</th>
          <th>이름</th>
          <th style="width:120px;">점수</th>
          <th style="width:160px;">투표에 등장(회)</th>
          <th style="width:140px;">최고 등수</th>
          <th style="width:140px;">최저 등수</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
    <p class="small" id="note"></p>
  </div>

  <p><a href="./index.html">홈으로</a></p>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="assets/config.js"></script>
  <script src="assets/supabase.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    const qs = (k) => new URLSearchParams(location.search).get(k);
    const esc = (s)=> (s??"").toString().replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");

    const sp = qs("session");
    if (sp) document.getElementById("sessionId").value = sp;

    let barChart = null;
    let pieChart = null;

    function destroyCharts() {
      if (barChart) { barChart.destroy(); barChart = null; }
      if (pieChart) { pieChart.destroy(); pieChart = null; }
    }

    async function loadResult() {
      const sessionId = document.getElementById("sessionId").value.trim();
      const msgEl = document.getElementById("msg");
      msgEl.textContent = "";
      destroyCharts();

      if (!sessionId) return;

      msgEl.textContent = "불러오는 중...";

      // 1) 세션
      const { data: session, error: sErr } = await sb
        .from("sessions")
        .select("*")
        .eq("id", sessionId)
        .single();

      if (sErr) { msgEl.textContent = "세션 로드 실패: " + sErr.message; return; }

      const candIds = session.candidate_ids || [];

      // 2) 후보 people (비활성 제외)
      const { data: people, error: pErr } = await sb
        .from("people")
        .select("id,name,is_active")
        .in("id", candIds);

      if (pErr) { msgEl.textContent = "후보 로드 실패: " + pErr.message; return; }

      const activePeople = people.filter(p => p.is_active !== false);
      const peopleMap = new Map(activePeople.map(p => [p.id, p.name]));
      const activeCandidateIds = candIds.filter(id => peopleMap.has(id));
      const M = activeCandidateIds.length;

      // 3) votes: ranking만
      const { data: votes, error: vErr } = await sb
        .from("votes")
        .select("ranking")
        .eq("session_id", sessionId);

      if (vErr) { msgEl.textContent = "투표 로드 실패: " + vErr.message; return; }

      const topK = session.top_k || 0;

      // ---- 집계 ----
      const scores = new Map(activeCandidateIds.map(id => [id, 0]));
      const appeared = new Map(activeCandidateIds.map(id => [id, 0]));
      const bestRank = new Map(activeCandidateIds.map(id => [id, Infinity])); // 최소
      const worstRank = new Map(activeCandidateIds.map(id => [id, -Infinity])); // 최대
      const firstCount = new Map(activeCandidateIds.map(id => [id, 0])); // 1등 횟수

      for (const v of votes) {
        const r0 = Array.isArray(v.ranking) ? v.ranking : [];

        // active 후보만 반영
        const filtered = r0.filter(id => activeCandidateIds.includes(id));

        // 점수/등수 집계 대상 (Top-k면 k명까지만)
        const effective = (topK > 0) ? filtered.slice(0, topK) : filtered;

        // 등장/최고/최저 등수는 effective 기준으로만 계산 (Top-k 밖은 "미선정"으로 간주)
        for (let i = 0; i < effective.length; i++) {
          const id = effective[i];
          const rank = i + 1;               // 1부터
          const pts = Math.max(M - 1 - i, 0);

          scores.set(id, (scores.get(id) || 0) + pts);
          appeared.set(id, (appeared.get(id) || 0) + 1);

          if (rank < bestRank.get(id)) bestRank.set(id, rank);
          if (rank > worstRank.get(id)) worstRank.set(id, rank);

          if (i === 0) firstCount.set(id, (firstCount.get(id) || 0) + 1);
        }
      }

      // 정렬: 점수 desc, appeared desc, 이름 asc
      const rows = activeCandidateIds.map(id => ({
        id,
        name: peopleMap.get(id) || "(알 수 없음)",
        score: scores.get(id) || 0,
        appeared: appeared.get(id) || 0,
        best: bestRank.get(id),
        worst: worstRank.get(id),
        first: firstCount.get(id) || 0
      })).sort((a, b) => {
        if (b.score !== a.score) return b.score - a.score;
        if (b.appeared !== a.appeared) return b.appeared - a.appeared;
        return a.name.localeCompare(b.name, "ko");
      });

      // ---- 렌더: 요약 ----
      document.getElementById("summary").style.display = "block";
      document.getElementById("resultCard").style.display = "block";
      document.getElementById("charts").style.display = "block";

      document.getElementById("title").textContent = session.title;
      document.getElementById("meta").textContent =
        `후보 ${M}명 · 방식: ${topK === 0 ? "전체 순위" : `Top-${topK}`}`;
      document.getElementById("voteCount").textContent = `투표 ${votes.length}건`;

      // ---- 렌더: 표 ----
      const tbody = document.getElementById("tbody");
      tbody.innerHTML = rows.map((r, idx) => {
        const bestTxt = (r.best === Infinity) ? "-" : r.best;
        const worstTxt = (r.worst === -Infinity) ? "-" : r.worst;
        return `
          <tr>
            <td>${idx + 1}</td>
            <td>${esc(r.name)}</td>
            <td>${r.score}</td>
            <td>${r.appeared}</td>
            <td>${bestTxt}</td>
            <td>${worstTxt}</td>
          </tr>
        `;
      }).join("");

      document.getElementById("note").textContent =
        (votes.length === 0)
          ? "아직 투표가 없습니다. (투표 링크로 투표한 뒤 다시 확인하세요)"
          : "집계 규칙: Borda Count. 최고/최저 등수는 (Top-k면) Top-k 내에서 집계됩니다.";

      // ---- 차트 데이터 준비 ----
      const labels = rows.map(r => r.name);
      const scoreData = rows.map(r => r.score);

      const firstTotal = rows.reduce((acc, r) => acc + r.first, 0);
      // 파이는 firstTotal=0이면 의미 없음 → 투표 0이거나 모두 Top-k=0인데 첫 rank가 없을 수는 없지만 대비
      const pieLabels = rows.filter(r => r.first > 0).map(r => r.name);
      const pieData = rows.filter(r => r.first > 0).map(r => r.first);

      // ---- 차트 그리기 ----
      const barCtx = document.getElementById("barScore");
      barChart = new Chart(barCtx, {
        type: "bar",
        data: {
          labels,
          datasets: [{ label: "Score (Borda)", data: scoreData }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true },
            tooltip: { enabled: true }
          },
          scales: {
            y: { beginAtZero: true }
          }
        }
      });

      const pieCtx = document.getElementById("pieFirst");
      if (firstTotal === 0) {
        // 투표가 없으면 빈 차트 대신 안내
        // (Chart.js로 빈 pie를 만들 수도 있지만, UX상 메시지가 더 명확)
        pieCtx.parentElement.innerHTML = `
          <h3 style="margin-top:0;">1등 득표 비중 (파이)</h3>
          <p class="small">표시할 데이터가 없습니다. (아직 투표가 없거나 1등 집계가 불가)</p>
        `;
      } else {
        pieChart = new Chart(pieCtx, {
          type: "pie",
          data: {
            labels: pieLabels,
            datasets: [{ label: "1st place votes", data: pieData }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: { display: true }
            }
          }
        });
      }

      msgEl.textContent = "완료";
    }

    document.getElementById("load").addEventListener("click", loadResult);
    if (sp) loadResult();
  </script>
</body>
</html>
